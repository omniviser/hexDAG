# ğŸ—ï¸ hexDAG System Architecture

**A comprehensive guide to how hexDAG works as a complete system**

---

## ğŸ“‹ Table of Contents

1. [Overview](#overview)
2. [System Architecture Diagram](#system-architecture-diagram)
3. [Core Components](#core-components)
4. [Execution Flow](#execution-flow)
5. [Data Flow](#data-flow)
6. [Component Interactions](#component-interactions)
7. [Lifecycle Management](#lifecycle-management)
8. [Extension Points](#extension-points)

---

## Overview

hexDAG is an enterprise-ready AI agent orchestration framework built on **hexagonal architecture** principles. The system transforms declarative YAML configurations into executable DAG workflows with comprehensive observability, type safety, and async-first execution.

### Design Principles

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    hexDAG Design Pillars                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. Async-First         â†’ Non-blocking I/O everywhere       â”‚
â”‚  2. Event-Driven        â†’ Complete observability            â”‚
â”‚  3. Type-Safe           â†’ Pydantic validation everywhere    â”‚
â”‚  4. Hexagonal           â†’ Clean architecture boundaries     â”‚
â”‚  5. Declarative         â†’ YAML-first workflow definition    â”‚
â”‚  6. DAG-Based           â†’ Intelligent dependency mgmt       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## System Architecture Diagram

### High-Level Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        hexDAG System                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  CONFIGURATION LAYER                                       â”‚     â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”‚
â”‚  â”‚                                                             â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚
â”‚  â”‚  â”‚   YAML       â”‚    â”‚   Manifest   â”‚    â”‚   Python    â”‚  â”‚     â”‚
â”‚  â”‚  â”‚   Files      â”‚â”€â”€â”€â–¶â”‚   Loader     â”‚â—€â”€â”€â”€â”‚   Code      â”‚  â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚  â”‚         â”‚                    â”‚                    â”‚         â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚            â”‚                    â”‚                    â”‚               â”‚
â”‚            â–¼                    â–¼                    â–¼               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  REGISTRY & DISCOVERY LAYER                                â”‚     â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”‚
â”‚  â”‚                                                             â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚     â”‚
â”‚  â”‚  â”‚          Component Registry (Singleton)             â”‚   â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚     â”‚
â”‚  â”‚  â”‚  â€¢ Bootstrap & Discovery                            â”‚   â”‚     â”‚
â”‚  â”‚  â”‚  â€¢ Component Storage (Nodes, Adapters, Tools, etc) â”‚   â”‚     â”‚
â”‚  â”‚  â”‚  â€¢ Schema Generation & Caching                      â”‚   â”‚     â”‚
â”‚  â”‚  â”‚  â€¢ Lifecycle Management                             â”‚   â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚     â”‚
â”‚  â”‚                         â”‚                                   â”‚     â”‚
â”‚  â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚     â”‚
â”‚  â”‚         â–¼               â–¼               â–¼                  â”‚     â”‚
â”‚  â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚     â”‚
â”‚  â”‚    â”‚ Nodes  â”‚     â”‚Adapters â”‚     â”‚  Tools  â”‚             â”‚     â”‚
â”‚  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                              â”‚                                       â”‚
â”‚                              â–¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  PIPELINE BUILDER LAYER                                    â”‚     â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”‚
â”‚  â”‚                                                             â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚
â”‚  â”‚  â”‚         YamlPipelineBuilder                          â”‚  â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚     â”‚
â”‚  â”‚  â”‚  1. YamlValidator    â†’ Schema validation            â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  2. ComponentInstantiator â†’ Create components       â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  3. NodeSpec Builder â†’ Build node specifications    â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  4. DirectedGraph Builder â†’ Assemble DAG            â”‚  â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚  â”‚                         â”‚                                   â”‚     â”‚
â”‚  â”‚                         â–¼                                   â”‚     â”‚
â”‚  â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚     â”‚
â”‚  â”‚              â”‚  DirectedGraph      â”‚                        â”‚     â”‚
â”‚  â”‚              â”‚  + PipelineConfig   â”‚                        â”‚     â”‚
â”‚  â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                              â”‚                                       â”‚
â”‚                              â–¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  ORCHESTRATION LAYER                                       â”‚     â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”‚
â”‚  â”‚                                                             â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚
â”‚  â”‚  â”‚              Orchestrator (Core Engine)              â”‚  â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚     â”‚
â”‚  â”‚  â”‚  Execution Context Management                        â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€ Ports Configuration                              â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€ Event System (Observer notifications)            â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â””â”€ Resource Management                              â”‚  â”‚     â”‚
â”‚  â”‚  â”‚                                                       â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  Wave Execution Pipeline                             â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€ Pre-DAG Hooks                                    â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€ Wave-by-Wave Execution                           â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”‚   â”œâ”€ InputMapper â†’ Resolve dependencies           â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”‚   â”œâ”€ Parallel Execution (asyncio.gather)          â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”‚   â””â”€ Result Collection                            â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â””â”€ Post-DAG Hooks                                   â”‚  â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚  â”‚                         â”‚                                   â”‚     â”‚
â”‚  â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚     â”‚
â”‚  â”‚         â–¼               â–¼               â–¼                  â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚     â”‚
â”‚  â”‚  â”‚   Wave 1  â”‚â”€â”€â”€â”‚   Wave 2  â”‚â”€â”€â”€â”‚   Wave N  â”‚            â”‚     â”‚
â”‚  â”‚  â”‚  (Nodes)  â”‚   â”‚  (Nodes)  â”‚   â”‚  (Nodes)  â”‚            â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                              â”‚                                       â”‚
â”‚                              â–¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  EXECUTION LAYER (Node Processing)                         â”‚     â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”‚
â”‚  â”‚                                                             â”‚     â”‚
â”‚  â”‚  For each node in each wave:                               â”‚     â”‚
â”‚  â”‚                                                             â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚
â”‚  â”‚  â”‚         Node Execution Pipeline                      â”‚  â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚     â”‚
â”‚  â”‚  â”‚  1. Input Resolution                                 â”‚  â”‚     â”‚
â”‚  â”‚  â”‚     â””â”€ InputMapper resolves {{dep.field}} refs       â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  2. Input Validation                                 â”‚  â”‚     â”‚
â”‚  â”‚  â”‚     â””â”€ Pydantic validation via in_model              â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  4. Function Execution                               â”‚  â”‚     â”‚
â”‚  â”‚  â”‚     â””â”€ async fn(ExecutionContext) â†’ result           â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  5. Output Validation                                â”‚  â”‚     â”‚
â”‚  â”‚  â”‚     â””â”€ Pydantic validation via out_model             â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  6. Result Storage                                   â”‚  â”‚     â”‚
â”‚  â”‚  â”‚     â””â”€ Store in ExecutionContext                     â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  7. Event Emission                                   â”‚  â”‚     â”‚
â”‚  â”‚  â”‚     â””â”€ NodeCompleted/NodeFailed events               â”‚  â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                              â”‚                                       â”‚
â”‚                              â–¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  INTEGRATION LAYER (Ports & Adapters)                     â”‚     â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”‚
â”‚  â”‚                                                             â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚
â”‚  â”‚  â”‚   Ports          â”‚          â”‚   Adapters             â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  (Interfaces)    â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  (Implementations)     â”‚  â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚     â”‚
â”‚  â”‚  â”‚  â€¢ LLM           â”‚          â”‚  â€¢ OpenAI              â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â€¢ Memory        â”‚          â”‚  â€¢ Anthropic           â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â€¢ Database      â”‚          â”‚  â€¢ PostgreSQL          â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â€¢ ToolRouter    â”‚          â”‚  â€¢ VectorDB            â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â€¢ FileStorage   â”‚          â”‚  â€¢ S3Storage           â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â€¢ Secret        â”‚          â”‚  â€¢ Mock adapters       â”‚  â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚  â”‚           â”‚                              â”‚                  â”‚     â”‚
â”‚  â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚     â”‚
â”‚  â”‚                          â–¼                                  â”‚     â”‚
â”‚  â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚     â”‚
â”‚  â”‚              â”‚  External Services   â”‚                       â”‚     â”‚
â”‚  â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                              â”‚                                       â”‚
â”‚                              â–¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  OBSERVABILITY LAYER (Event System)                        â”‚     â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”‚
â”‚  â”‚                                                             â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚
â”‚  â”‚  â”‚          Event System & Observers                    â”‚  â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚     â”‚
â”‚  â”‚  â”‚  Event Types:                                        â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€ PipelineStarted / PipelineCompleted             â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€ WaveStarted / WaveCompleted                      â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€ NodeStarted / NodeCompleted / NodeFailed         â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€ ValidationError                                  â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â””â”€ Custom Events                                    â”‚  â”‚     â”‚
â”‚  â”‚  â”‚                                                       â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  Observers:                                           â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€ MemoryObserver â†’ Store execution history         â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€ LoggingObserver â†’ Structured logging             â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€ MetricsObserver â†’ Performance tracking           â”‚  â”‚     â”‚
â”‚  â”‚  â”‚  â””â”€ Custom Observers                                 â”‚  â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Core Components

### 1. Component Registry

**Purpose**: Central hub for component discovery, storage, and lifecycle management.

**Responsibilities**:
- **Bootstrap**: Load components from manifest configuration
- **Discovery**: Find and register components from Python modules
- **Storage**: Maintain flat storage of all registered components
- **Schema Generation**: Generate JSON schemas for components
- **Validation**: Ensure component uniqueness and correctness

**Component Types**:
- **Nodes**: Pipeline processing steps (LLMNode, FunctionNode, AgentNode)
- **Adapters**: Port implementations (OpenAIAdapter, MockLLM)
- **Tools**: Functions for agent use
- **Macros**: Reusable pipeline templates

**Component Resolution**:

Components are resolved by full module path using `hexdag.core.resolver`:

```python
from hexdag.core.resolver import resolve

# Resolve components by module path
OpenAIAdapter = resolve("hexdag.builtin.adapters.openai.OpenAIAdapter")
MyNode = resolve("myapp.nodes.MyNode")
```

**Creating Custom Components**:

```python
# Custom adapter - implement port interface
from hexdag.core.ports.llm import LLM

class OpenAIAdapter(LLM):
    def __init__(self, api_key: str, model: str = "gpt-4"):
        self.api_key = api_key
        self.model = model

# Custom node - extend BaseNodeFactory
from hexdag.builtin.nodes import BaseNodeFactory

class MyNode(BaseNodeFactory):
    def __call__(self, name: str, timeout: float = 30.0, **kwargs):
        return NodeSpec(...)
```

### 2. DirectedGraph

**Purpose**: Immutable representation of workflow structure with dependency management.

**Key Features**:
- **Node Storage**: Maintains NodeSpec instances
- **Dependency Tracking**: Explicit dependency relationships
- **Cycle Detection**: DFS-based cycle detection algorithm
- **Topological Sorting**: Computes execution waves
- **Validation**: Ensures graph is valid DAG

**Data Structure**:
```python
@dataclass(frozen=True, slots=True)
class NodeSpec:
    """Immutable node specification."""
    name: str                         # Unique node identifier
    fn: Callable[..., Any]            # Execution function
    in_model: type[BaseModel] | None  # Input schema
    out_model: type[BaseModel] | None # Output schema
    deps: frozenset[str]              # Dependency node names
    params: dict[str, Any]            # Configuration parameters
    timeout: float | None             # Execution timeout
```

**Graph Operations**:
```python
graph = DirectedGraph()

# Add nodes
graph.add(NodeSpec(name="step1", fn=func1))
graph.add(NodeSpec(name="step2", fn=func2, deps={"step1"}))

# Validate (automatic on add)
graph.validate()  # Checks cycles, dependencies

# Compute execution waves
waves = graph.topological_waves()
# Result: [[step1], [step2]]  # Can execute step1, then step2
```

### 3. YamlPipelineBuilder

**Purpose**: Transform YAML configurations into executable DirectedGraphs.

**Processing Pipeline**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          YamlPipelineBuilder Pipeline                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  YAML File                                                   â”‚
â”‚     â†“                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  1. YAML Parsing                        â”‚                â”‚
â”‚  â”‚     â”œâ”€ yaml.safe_load()                 â”‚                â”‚
â”‚  â”‚     â””â”€ Caching (lru_cache)              â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚     â†“                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  2. Schema Validation (YamlValidator)   â”‚                â”‚
â”‚  â”‚     â”œâ”€ Check required fields            â”‚                â”‚
â”‚  â”‚     â”œâ”€ Validate node types exist        â”‚                â”‚
â”‚  â”‚     â”œâ”€ Validate dependencies            â”‚                â”‚
â”‚  â”‚     â””â”€ Check for cycles                 â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚     â†“                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  3. Component Instantiation             â”‚                â”‚
â”‚  â”‚     â”œâ”€ Resolve component from registry  â”‚                â”‚
â”‚  â”‚     â”œâ”€ Extract secrets                  â”‚                â”‚
â”‚  â”‚     â”œâ”€ Merge params                     â”‚                â”‚
â”‚  â”‚     â””â”€ Create component instance        â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚     â†“                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  4. NodeSpec Construction               â”‚                â”‚
â”‚  â”‚     â”œâ”€ Call node factory                â”‚                â”‚
â”‚  â”‚     â”œâ”€ Set dependencies                 â”‚                â”‚
â”‚  â”‚     â””â”€ Create immutable NodeSpec        â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚     â†“                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  5. DirectedGraph Assembly              â”‚                â”‚
â”‚  â”‚     â”œâ”€ Add all NodeSpecs                â”‚                â”‚
â”‚  â”‚     â”œâ”€ Validate DAG structure           â”‚                â”‚
â”‚  â”‚     â””â”€ Compute topological order        â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚     â†“                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  6. PipelineConfig Creation             â”‚                â”‚
â”‚  â”‚     â”œâ”€ Extract ports configuration      â”‚                â”‚
â”‚  â”‚     â”œâ”€ Extract policies                 â”‚                â”‚
â”‚  â”‚     â”œâ”€ Extract observers                â”‚                â”‚
â”‚  â”‚     â””â”€ Package metadata                 â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚     â†“                                                        â”‚
â”‚  DirectedGraph + PipelineConfig                              â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**YAML Structure**:
```yaml
apiVersion: hexdag/v1
kind: Pipeline
metadata:
  name: my_workflow
  description: Example workflow

spec:
  nodes:
    - type: llm
      id: analyzer
      params:
        prompt_template: "Analyze: {{input.text}}"
        model: gpt-4
      depends_on: []

    - type: function
      id: processor
      params:
        fn: my_module.process_data
      depends_on: [analyzer]

  ports:
    llm:
      adapter: openai
      params:
        api_key: "${OPENAI_API_KEY}"
        model: gpt-4

  policies:
    - type: retry
      params:
        max_retries: 3
        backoff: 1.0
```

### 4. Orchestrator

**Purpose**: Core execution engine that walks DirectedGraphs in topological order.

**Execution Architecture**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Orchestrator Execution Flow                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  async def run(graph, input_data) â†’ results:                 â”‚
â”‚                                                               â”‚
â”‚  1. INITIALIZATION                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  â€¢ Create ExecutionContext                          â”‚     â”‚
â”‚  â”‚  â€¢ Initialize Ports (LLM, Memory, etc)              â”‚     â”‚
â”‚  â”‚  â€¢ Setup Event System                               â”‚     â”‚
â”‚  â”‚  â€¢ Call adapter.asetup() for all adapters           â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                        â†“                                      â”‚
â”‚  2. PRE-DAG HOOKS                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  â€¢ Execute pre-DAG hooks in sequence                â”‚     â”‚
â”‚  â”‚  â€¢ Can modify input_data or abort pipeline          â”‚     â”‚
â”‚  â”‚  â€¢ Emit PipelineStarted event                       â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                        â†“                                      â”‚
â”‚  3. WAVE EXECUTION (for each wave in topological order)      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  Wave N Execution:                                  â”‚     â”‚
â”‚  â”‚                                                      â”‚     â”‚
â”‚  â”‚  â€¢ Emit WaveStarted event                           â”‚     â”‚
â”‚  â”‚  â€¢ For each node in wave (parallel):                â”‚     â”‚
â”‚  â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚     â”‚
â”‚  â”‚    â”‚  Node Execution Pipeline:                â”‚     â”‚     â”‚
â”‚  â”‚    â”‚                                           â”‚     â”‚     â”‚
â”‚  â”‚    â”‚  a. Input Resolution                      â”‚     â”‚     â”‚
â”‚  â”‚    â”‚     â””â”€ InputMapper.resolve_inputs()       â”‚     â”‚     â”‚
â”‚  â”‚    â”‚        â€¢ Resolve {{dep.field}} refs       â”‚     â”‚     â”‚
â”‚  â”‚    â”‚        â€¢ Merge with node params           â”‚     â”‚     â”‚
â”‚  â”‚    â”‚                                           â”‚     â”‚     â”‚
â”‚  â”‚    â”‚  b. Emit NodeStarted event                â”‚     â”‚     â”‚
â”‚  â”‚    â”‚                                           â”‚     â”‚     â”‚
â”‚  â”‚    â”‚  c. Input Validation                      â”‚     â”‚     â”‚
â”‚  â”‚    â”‚     â””â”€ node.validate_input(data)          â”‚     â”‚     â”‚
â”‚  â”‚    â”‚        â€¢ Pydantic model validation        â”‚     â”‚     â”‚
â”‚  â”‚    â”‚                                           â”‚     â”‚     â”‚
â”‚  â”‚    â”‚  d. Function Execution                    â”‚     â”‚     â”‚
â”‚  â”‚    â”‚     â””â”€ await node.fn(context, **inputs)   â”‚     â”‚     â”‚
â”‚  â”‚    â”‚        â€¢ Timeout handling                 â”‚     â”‚     â”‚
â”‚  â”‚    â”‚        â€¢ Error capture                    â”‚     â”‚     â”‚
â”‚  â”‚    â”‚                                           â”‚     â”‚     â”‚
â”‚  â”‚    â”‚  e. Output Validation                     â”‚     â”‚     â”‚
â”‚  â”‚    â”‚     â””â”€ node.validate_output(result)       â”‚     â”‚     â”‚
â”‚  â”‚    â”‚        â€¢ Pydantic model validation        â”‚     â”‚     â”‚
â”‚  â”‚    â”‚                                           â”‚     â”‚     â”‚
â”‚  â”‚    â”‚  f. Result Storage                        â”‚     â”‚     â”‚
â”‚  â”‚    â”‚     â””â”€ context.set_result(node, result)   â”‚     â”‚     â”‚
â”‚  â”‚    â”‚                                           â”‚     â”‚     â”‚
â”‚  â”‚    â”‚  h. Emit NodeCompleted event              â”‚     â”‚     â”‚
â”‚  â”‚    â”‚                                           â”‚     â”‚     â”‚
â”‚  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚     â”‚
â”‚  â”‚                                                      â”‚     â”‚
â”‚  â”‚  â€¢ Wait for all nodes: asyncio.gather(*tasks)       â”‚     â”‚
â”‚  â”‚  â€¢ Emit WaveCompleted event                         â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                        â†“                                      â”‚
â”‚  4. POST-DAG HOOKS                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  â€¢ Execute post-DAG hooks in sequence               â”‚     â”‚
â”‚  â”‚  â€¢ Can modify results                               â”‚     â”‚
â”‚  â”‚  â€¢ Emit PipelineCompleted event                     â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                        â†“                                      â”‚
â”‚  5. CLEANUP                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  â€¢ Call adapter.aclose() for all adapters           â”‚     â”‚
â”‚  â”‚  â€¢ Cleanup resources                                â”‚     â”‚
â”‚  â”‚  â€¢ Return results                                   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Orchestrator Components**:

1. **InputMapper**: Resolves template expressions like `{{dep.field}}`
2. **ExecutionContext**: Thread-safe context for ports, results, and metadata
3. **WaveExecutor**: Manages parallel execution within a wave
4. **ExecutionCoordinator**: Handles observer notifications and input mapping
5. **EventManager**: Emits events for observability

### 5. Ports & Adapters (Hexagonal Architecture)

**Purpose**: Clean separation between business logic and external services.

**Architecture**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Hexagonal Architecture Pattern                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚            Business Logic Core                â”‚           â”‚
â”‚  â”‚         (Orchestrator, Nodes, DAG)            â”‚           â”‚
â”‚  â”‚                                               â”‚           â”‚
â”‚  â”‚  Depends ONLY on Port interfaces, not        â”‚           â”‚
â”‚  â”‚  concrete implementations                     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                      â”‚                                        â”‚
â”‚                      â”‚ Uses interfaces only                   â”‚
â”‚                      â–¼                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚              Port Layer                       â”‚           â”‚
â”‚  â”‚         (Abstract Interfaces)                 â”‚           â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚  â”‚                                               â”‚           â”‚
â”‚  â”‚  class LLMPort(Protocol):                    â”‚           â”‚
â”‚  â”‚      async def aresponse(                    â”‚           â”‚
â”‚  â”‚          self,                                â”‚           â”‚
â”‚  â”‚          messages: list[dict]                 â”‚           â”‚
â”‚  â”‚      ) -> str: ...                            â”‚           â”‚
â”‚  â”‚                                               â”‚           â”‚
â”‚  â”‚  class MemoryPort(Protocol):                 â”‚           â”‚
â”‚  â”‚      async def aget(                          â”‚           â”‚
â”‚  â”‚          self, key: str                       â”‚           â”‚
â”‚  â”‚      ) -> Any: ...                            â”‚           â”‚
â”‚  â”‚                                               â”‚           â”‚
â”‚  â”‚  class DatabasePort(Protocol):               â”‚           â”‚
â”‚  â”‚      async def aexecute_query(                â”‚           â”‚
â”‚  â”‚          self, sql: str                       â”‚           â”‚
â”‚  â”‚      ) -> list[dict]: ...                     â”‚           â”‚
â”‚  â”‚                                               â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                      â”‚                                        â”‚
â”‚                      â”‚ Implemented by                         â”‚
â”‚                      â–¼                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚           Adapter Layer                       â”‚           â”‚
â”‚  â”‚    (Concrete Implementations)                 â”‚           â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚  â”‚                                               â”‚           â”‚
â”‚  â”‚  class OpenAIAdapter(LLM):                   â”‚           â”‚
â”‚  â”‚      async def aresponse(...) -> str:        â”‚           â”‚
â”‚  â”‚          # OpenAI API call                    â”‚           â”‚
â”‚  â”‚                                               â”‚           â”‚
â”‚  â”‚  class AnthropicAdapter(LLM):                â”‚           â”‚
â”‚  â”‚      async def aresponse(...) -> str:        â”‚           â”‚
â”‚  â”‚          # Anthropic API call                 â”‚           â”‚
â”‚  â”‚                                               â”‚           â”‚
â”‚  â”‚  class RedisMemoryAdapter(Memory):           â”‚           â”‚
â”‚  â”‚      async def aget(...) -> Any:             â”‚           â”‚
â”‚  â”‚          # Redis GET operation                â”‚           â”‚
â”‚  â”‚                                               â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                      â”‚                                        â”‚
â”‚                      â”‚ Calls                                  â”‚
â”‚                      â–¼                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚          External Services                    â”‚           â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚  â”‚  â€¢ OpenAI API                                 â”‚           â”‚
â”‚  â”‚  â€¢ Anthropic API                              â”‚           â”‚
â”‚  â”‚  â€¢ PostgreSQL Database                        â”‚           â”‚
â”‚  â”‚  â€¢ Redis Cache                                â”‚           â”‚
â”‚  â”‚  â€¢ S3 Storage                                 â”‚           â”‚
â”‚  â”‚  â€¢ Vector Databases                           â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Benefits**:
- **Testability**: Easy to test with mock adapters
- **Flexibility**: Swap implementations without changing business logic
- **Maintainability**: Clear separation of concerns
- **Vendor Independence**: Not locked to specific service providers

### 6. Event System

**Purpose**: Comprehensive observability through event-driven architecture.

**Event Flow**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Event System Architecture                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  Orchestrator Execution                                       â”‚
â”‚         â”‚                                                     â”‚
â”‚         â”‚ emit_event()                                        â”‚
â”‚         â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚      ObserverManagerPort                â”‚                 â”‚
â”‚  â”‚  (Event Bus / Pub-Sub System)           â”‚                 â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                 â”‚
â”‚  â”‚  â€¢ Event Queue                          â”‚                 â”‚
â”‚  â”‚  â€¢ Observer Registry                    â”‚                 â”‚
â”‚  â”‚  â€¢ Async Event Distribution             â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚            â”‚                                                  â”‚
â”‚            â”‚ notify_observers()                               â”‚
â”‚            â”‚                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â–¼                    â–¼          â–¼          â–¼         â–¼      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Memory  â”‚   â”‚ Logging  â”‚  â”‚Metricsâ”‚  â”‚ Custom â”‚  â”‚... â”‚  â”‚
â”‚  â”‚Observer â”‚   â”‚Observer  â”‚  â”‚Observer  â”‚Observer â”‚  â”‚    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”˜  â”‚
â”‚      â”‚              â”‚            â”‚           â”‚                â”‚
â”‚      â–¼              â–¼            â–¼           â–¼                â”‚
â”‚  Store in     Write to     Track perf    Custom              â”‚
â”‚  Memory       Logs         metrics        logic              â”‚
â”‚  Port         (JSON)       (Prometheus)                       â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Event Types**:

```python
# Pipeline-level events
PipelineStarted(pipeline_id, graph, input_data)
PipelineCompleted(pipeline_id, results, duration)
PipelineFailed(pipeline_id, error)
PipelineCancelled(pipeline_id)

# Wave-level events
WaveStarted(wave_index, node_names)
WaveCompleted(wave_index, results, duration)

# Node-level events
NodeStarted(node_name, wave_index, inputs)
NodeCompleted(node_name, output, duration)
NodeFailed(node_name, error, traceback)

# Validation events
ValidationError(node_name, error_details)
```

---

## Execution Flow

### Complete Request Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Complete Request Flow (YAML to Results)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  1. User provides YAML file                                   â”‚
â”‚     â†“                                                         â”‚
â”‚  2. YamlPipelineBuilder parses and validates                  â”‚
â”‚     â”œâ”€ Validate schema                                        â”‚
â”‚     â”œâ”€ Resolve components from registry                       â”‚
â”‚     â””â”€ Build DirectedGraph                                    â”‚
â”‚     â†“                                                         â”‚
â”‚  3. Create Orchestrator with PipelineConfig                   â”‚
â”‚     â”œâ”€ Initialize ports (LLM, Memory, etc)                    â”‚
â”‚     â”œâ”€ Setup event system                                     â”‚
â”‚     â””â”€ Initialize policies                                    â”‚
â”‚     â†“                                                         â”‚
â”‚  4. Call orchestrator.run(graph, input_data)                  â”‚
â”‚     â”‚                                                         â”‚
â”‚     â”œâ”€ Execute pre-DAG hooks                                  â”‚
â”‚     â”‚  â””â”€ Can modify input or abort                           â”‚
â”‚     â”‚                                                         â”‚
â”‚     â”œâ”€ For each wave (topological order):                     â”‚
â”‚     â”‚  â”‚                                                      â”‚
â”‚     â”‚  â”œâ”€ Emit WaveStarted                                    â”‚
â”‚     â”‚  â”‚                                                      â”‚
â”‚     â”‚  â”œâ”€ For each node in wave (parallel):                   â”‚
â”‚     â”‚  â”‚  â”‚                                                   â”‚
â”‚     â”‚  â”‚  â”œâ”€ Resolve inputs from dependencies                 â”‚
â”‚     â”‚  â”‚  â”œâ”€ Evaluate policies                                â”‚
â”‚     â”‚  â”‚  â”œâ”€ Emit NodeStarted                                 â”‚
â”‚     â”‚  â”‚  â”œâ”€ Validate inputs (Pydantic)                       â”‚
â”‚     â”‚  â”‚  â”œâ”€ Execute node function                            â”‚
â”‚     â”‚  â”‚  â”‚  â””â”€ May call ports (LLM, Memory, etc)             â”‚
â”‚     â”‚  â”‚  â”œâ”€ Validate outputs (Pydantic)                      â”‚
â”‚     â”‚  â”‚  â”œâ”€ Store results                                    â”‚
â”‚     â”‚  â”‚  â””â”€ Emit NodeCompleted                               â”‚
â”‚     â”‚  â”‚                                                      â”‚
â”‚     â”‚  â”œâ”€ Wait for all nodes: asyncio.gather()                â”‚
â”‚     â”‚  â””â”€ Emit WaveCompleted                                  â”‚
â”‚     â”‚                                                         â”‚
â”‚     â”œâ”€ Execute post-DAG hooks                                 â”‚
â”‚     â”‚  â””â”€ Can modify results                                  â”‚
â”‚     â”‚                                                         â”‚
â”‚     â””â”€ Cleanup resources                                      â”‚
â”‚        â””â”€ Call adapter.aclose()                               â”‚
â”‚     â†“                                                         â”‚
â”‚  5. Return execution results                                  â”‚
â”‚     â””â”€ Results dictionary with all node outputs               â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Data Flow

### Dependency Resolution

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Dependency Resolution & Data Flow                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  Example YAML:                                                â”‚
â”‚  nodes:                                                       â”‚
â”‚    - type: llm                                                â”‚
â”‚      id: analyzer                                             â”‚
â”‚      params:                                                  â”‚
â”‚        prompt_template: "Analyze: {{input.text}}"            â”‚
â”‚                                                               â”‚
â”‚    - type: function                                           â”‚
â”‚      id: processor                                            â”‚
â”‚      params:                                                  â”‚
â”‚        data: "{{analyzer.result}}"                           â”‚
â”‚      depends_on: [analyzer]                                   â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  Execution Flow:                                 â”‚        â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤        â”‚
â”‚  â”‚                                                   â”‚        â”‚
â”‚  â”‚  Wave 0: [analyzer]                              â”‚        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚        â”‚
â”‚  â”‚  â”‚  analyzer node                     â”‚          â”‚        â”‚
â”‚  â”‚  â”‚  1. InputMapper resolves:          â”‚          â”‚        â”‚
â”‚  â”‚  â”‚     {{input.text}} â†’ from input    â”‚          â”‚        â”‚
â”‚  â”‚  â”‚  2. Execute LLM call               â”‚          â”‚        â”‚
â”‚  â”‚  â”‚  3. Store result: {"result": "..."} â”‚         â”‚        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚        â”‚
â”‚  â”‚           â†“                                       â”‚        â”‚
â”‚  â”‚  Wave 1: [processor]                             â”‚        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚        â”‚
â”‚  â”‚  â”‚  processor node                    â”‚          â”‚        â”‚
â”‚  â”‚  â”‚  1. InputMapper resolves:          â”‚          â”‚        â”‚
â”‚  â”‚  â”‚     {{analyzer.result}}            â”‚          â”‚        â”‚
â”‚  â”‚  â”‚     â†’ Look up "analyzer" in resultsâ”‚          â”‚        â”‚
â”‚  â”‚  â”‚     â†’ Extract "result" field       â”‚          â”‚        â”‚
â”‚  â”‚  â”‚     â†’ Pass to processor            â”‚          â”‚        â”‚
â”‚  â”‚  â”‚  2. Execute function               â”‚          â”‚        â”‚
â”‚  â”‚  â”‚  3. Store result                   â”‚          â”‚        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚        â”‚
â”‚  â”‚                                                   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Template Resolution

**InputMapper** resolves template expressions in this order:

1. **Dependency References**: `{{dep_name.field}}` â†’ Look up previous node results
2. **Input Data**: `{{input.field}}` â†’ Look up original input data
3. **Context Variables**: `{{ctx.pipeline_id}}` â†’ Execution context metadata
4. **Environment Variables**: `${ENV_VAR}` â†’ System environment variables

---

## Component Interactions

### Registry â†’ Builder â†’ Orchestrator Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Component Interaction Sequence                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  System Startup:                                              â”‚
â”‚  1. Bootstrap Registry                                        â”‚
â”‚     â”œâ”€ Load manifest.toml                                     â”‚
â”‚     â”œâ”€ Import core modules                                    â”‚
â”‚     â”œâ”€ Import plugin modules                                  â”‚
â”‚     â””â”€ Register all components                                â”‚
â”‚                                                               â”‚
â”‚  Pipeline Execution:                                          â”‚
â”‚  2. YamlPipelineBuilder.build_from_yaml_file()                â”‚
â”‚     â”œâ”€ Parse YAML                                             â”‚
â”‚     â”œâ”€ For each node:                                         â”‚
â”‚     â”‚  â”œâ”€ resolve(node_type) â†’ Get factory class              â”‚
â”‚     â”‚  â”œâ”€ factory(**params) â†’ Create NodeSpec                 â”‚
â”‚     â”‚  â””â”€ graph.add(node_spec)                                â”‚
â”‚     â”œâ”€ graph.validate()                                       â”‚
â”‚     â””â”€ Return (graph, config)                                 â”‚
â”‚                                                               â”‚
â”‚  3. Create Orchestrator                                       â”‚
â”‚     â”œâ”€ For each port in config.ports:                         â”‚
â”‚     â”‚  â”œâ”€ resolve(adapter_path) â†’ Get adapter class           â”‚
â”‚     â”‚  â”œâ”€ adapter(**params) â†’ Create instance                 â”‚
â”‚     â”‚  â””â”€ Store in ports dict                                 â”‚
â”‚     â””â”€ Setup event system                                     â”‚
â”‚                                                               â”‚
â”‚  4. Orchestrator.run(graph, input_data)                       â”‚
â”‚     â”œâ”€ Initialize ExecutionContext                            â”‚
â”‚     â”‚  â”œâ”€ ctx.ports = ports                                   â”‚
â”‚     â”‚  â”œâ”€ ctx.results = {}                                    â”‚
â”‚     â”‚  â””â”€ ctx.event_manager = event_manager                   â”‚
â”‚     â”œâ”€ For each wave:                                         â”‚
â”‚     â”‚  â””â”€ For each node:                                      â”‚
â”‚     â”‚     â”œâ”€ node.fn(ctx, **inputs)                           â”‚
â”‚     â”‚     â”‚  â””â”€ Can access ctx.ports.llm.aresponse()          â”‚
â”‚     â”‚     â””â”€ Store result in ctx.results                      â”‚
â”‚     â””â”€ Return ctx.results                                     â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Lifecycle Management

### Adapter Lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Adapter Lifecycle Hooks                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  class PostgresAdapter(Database):                             â”‚
â”‚  # Implements Database port interface                                       â”‚
â”‚      def __init__(self, connection_string: str):              â”‚
â”‚          self.connection_string = connection_string           â”‚
â”‚          self.pool = None  # Initialize later                 â”‚
â”‚                                                               â”‚
â”‚      async def asetup(self) -> None:                          â”‚
â”‚          """Called once when orchestrator starts."""          â”‚
â”‚          self.pool = await asyncpg.create_pool(               â”‚
â”‚              self.connection_string                           â”‚
â”‚          )                                                    â”‚
â”‚          logger.info("Database pool created")                 â”‚
â”‚                                                               â”‚
â”‚      async def aclose(self) -> None:                          â”‚
â”‚          """Called once when orchestrator finishes."""        â”‚
â”‚          if self.pool:                                        â”‚
â”‚              await self.pool.close()                          â”‚
â”‚              logger.info("Database pool closed")              â”‚
â”‚                                                               â”‚
â”‚      async def aexecute_query(self, sql: str):                â”‚
â”‚          """Business logic methods."""                        â”‚
â”‚          async with self.pool.acquire() as conn:              â”‚
â”‚              return await conn.fetch(sql)                     â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  Orchestrator manages lifecycle:                 â”‚        â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤        â”‚
â”‚  â”‚                                                   â”‚        â”‚
â”‚  â”‚  async with orchestrator.run(graph, data):       â”‚        â”‚
â”‚  â”‚      # 1. Call adapter.asetup()                  â”‚        â”‚
â”‚  â”‚      # 2. Execute graph                          â”‚        â”‚
â”‚  â”‚      # 3. Call adapter.aclose()                  â”‚        â”‚
â”‚  â”‚                                                   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Pipeline Lifecycle

```
Pipeline Startup:
  1. Parse YAML â†’ DirectedGraph
  2. Initialize Ports (adapters)
  3. Call adapter.asetup() for all adapters
  4. Setup event system
  5. Initialize policies

Pipeline Execution:
  6. Execute pre-DAG hooks
  7. For each wave:
     - Execute nodes in parallel
     - Collect results
  8. Execute post-DAG hooks

Pipeline Shutdown:
  9. Call adapter.aclose() for all adapters
  10. Cleanup resources
  11. Return results
```

---

## Extension Points

hexDAG provides multiple extension points for customization:

### 1. Custom Nodes

Extend `BaseNodeFactory` and reference by full module path:

```python
from hexdag.core.domain.dag import NodeSpec
from hexdag.builtin.nodes import BaseNodeFactory

class CustomProcessorNode(BaseNodeFactory):
    def __call__(self, name: str, config: dict, **kwargs):
        async def process(ctx: ExecutionContext, **inputs):
            # Custom processing logic
            result = await custom_processing(inputs, config)
            return result

        return NodeSpec(
            name=name,
            fn=process,
            deps=kwargs.get("depends_on", frozenset()),
            params=config
        )
```

Use in YAML: `kind: myapp.nodes.CustomProcessorNode`

### 2. Custom Adapters

Implement the port interface (e.g., `LLM`, `Memory`, `Database`):

```python
class CustomCacheAdapter:
    def __init__(self, api_key: str | None = None, ttl: int = 3600):
        self.api_key = api_key or os.environ.get("CACHE_API_KEY")
        self.ttl = ttl

    async def asetup(self):
        # Initialize connection
        pass

    async def aget(self, key: str):
        # Custom get logic
        pass

    async def aclose(self):
        # Cleanup
        pass
```

Use in YAML: `adapter: myapp.adapters.CustomCacheAdapter`

### 3. Custom Tools

Tools are plain functions with type hints and docstrings:

```python
def web_search(query: str, limit: int = 10) -> list[dict]:
    """Search the web for information.

    Args:
        query: Search query
        limit: Maximum results to return

    Returns:
        List of search results
    """
    # Custom search logic
    return search_results
```

Use in YAML: `tools: [myapp.tools.web_search]`

### 4. Custom Observers

Implement the observer interface:

```python
from hexdag.core.orchestration.events import NodeCompleted

class PerformanceMonitor:
    async def on_event(self, event):
        if isinstance(event, NodeCompleted):
            # Track performance metrics
            duration = event.duration
            node_name = event.node_name
            await metrics_client.record(node_name, duration)
```

### 5. Custom Hooks

```python
# Pre-DAG hook to validate input
async def validate_input_hook(context):
    if not context.input_data.get("required_field"):
        raise ValueError("Missing required field")
    return context

# Post-DAG hook to transform output
async def transform_output_hook(context):
    results = context.results
    # Transform results
    context.results = transformed_results
    return context

# Register hooks
orchestrator = Orchestrator(
    pre_dag_hooks=[validate_input_hook],
    post_dag_hooks=[transform_output_hook]
)
```

---

## Summary

hexDAG's architecture provides:

1. **Clean Separation**: Hexagonal architecture isolates business logic
2. **Type Safety**: Pydantic validation at every layer
3. **Observability**: Comprehensive event system for monitoring
4. **Flexibility**: Multiple extension points for customization
5. **Performance**: Async-first design with parallel execution
6. **Maintainability**: Clear component boundaries and responsibilities
7. **Declarative**: YAML-first approach for low-code development
8. **Testability**: Mock adapters and clear interfaces

The system is designed for **enterprise-grade AI agent orchestration** with production-ready patterns for error handling, monitoring, and extensibility.

---

**See Also**:
- [Core Concepts](concepts.md) - Understanding hexDAG fundamentals
- [Implementation Guide](IMPLEMENTATION_GUIDE.md) - Building production workflows
- [Plugin System](PLUGIN_SYSTEM.md) - Extending hexDAG
- [Philosophy](PHILOSOPHY.md) - Design principles and comparisons
