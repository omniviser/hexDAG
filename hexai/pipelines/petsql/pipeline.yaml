name: petsql_pipeline
description: PetSQL text-to-SQL generation using hexAI framework with two-stage generation - Refactored with Input Mappings

nodes:
  # Input processing (Wave 1 - parallel execution)
  - type: function
    id: query_extractor
    params:
      fn: extract_user_query
    depends_on: []

  - type: function
    id: schema_loader
    params:
      fn: load_database_schema
    depends_on: []

  # Example selection using embedding similarity (Wave 2)
  - type: function
    id: example_selector
    params:
      fn: select_examples
      input_mapping:
        query_data: "query_extractor"
    depends_on: [query_extractor]

  # Schema filtering for relevance (Wave 3)
  - type: function
    id: schema_filter
    params:
      fn: filter_relevant_schema
      input_mapping:
        query_data: "query_extractor"
        schema_data: "schema_loader"
    depends_on: [query_extractor, schema_loader]

  # Pre-SQL generation with filtered schema (Wave 4)
  - type: llm
    id: presql_generator
    params:
      prompt_template: |
        ### Answer the question by SQLite SQL query only and with no explanation.
        You must minimize SQL execution time while ensuring correctness.

        ### Database Schema:
        {{ddls}}

        ### Foreign Keys:
        {{foreign_keys}}

        ### Question: {{user_query}}
        ### SQL:
      input_mapping:
        user_query: "query_extractor.user_query"
        ddls: "schema_filter.filtered_ddls"
        foreign_keys: "schema_filter.foreign_keys"
    depends_on: [query_extractor, schema_filter, example_selector]

  # Extract table names from pre-SQL (Wave 5)
  - type: function
    id: table_extractor
    params:
      fn: sql_validator
      input_mapping:
        sql_data: "presql_generator"
        schema_data: "schema_loader"
    depends_on: [presql_generator, schema_loader]

  # Generate final SQL with focused schema (Wave 6)
  - type: llm
    id: final_sql_generator
    params:
      prompt_template: |
        ### Answer the question by SQLite SQL query only and with no explanation.
        You must minimize SQL execution time while ensuring correctness.

        ### Database Schema:
        {{ddls}}

        ### Question: {{user_query}}
        ### SQL:
      input_mapping:
        user_query: "query_extractor.user_query"
        ddls: "table_extractor.focused_ddls"
    depends_on: [query_extractor, table_extractor, example_selector]

  # Convert SQLite to PostgreSQL (Wave 7)
  - type: function
    id: postgres_converter
    params:
      fn: convert_sqlite_to_postgres
      input_mapping:
        sql_data: "final_sql_generator"
    depends_on: [final_sql_generator]
